<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>현실적 3D 자동차 시뮬레이터</title>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<style>
  body {
    margin: 0; overflow: hidden; background: #222;
    font-family: 'Arial', sans-serif;
    user-select: none;
    -webkit-user-select:none;
    -moz-user-select:none;
    -ms-user-select:none;
  }
  #container {
    width: 100vw; height: 100vh; position: relative;
    background: #222;
  }
  #warning {
    position: absolute; top:0; left:0; width:100vw; height:100vh;
    background:#111; color:#f44;
    display:none;
    justify-content:center; align-items:center;
    font-size:24px; font-weight:bold; text-align:center;
    padding:20px; box-sizing:border-box;
    z-index:9999;
  }
  #overlay {
    position: absolute; top: 10px; left: 10px; color: #eee; font-size: 18px;
    background: rgba(0,0,0,0.3); padding: 8px 12px;
    border-radius: 8px; font-weight: bold; min-width: 140px; text-align:center;
    user-select:none; z-index:100;
  }
  #controls {
    position: absolute; bottom: 20px; width: 100%;
    display: flex; justify-content: space-between;
    padding: 0 20px; box-sizing: border-box; user-select:none; z-index:100;
  }
  .button-group {
    display: flex; gap: 10px; align-items: center;
  }
  button {
    background: #4f9eff; border: none; border-radius: 10px;
    color: white; font-weight: 600;
    padding: 10px 14px; cursor: pointer;
    font-size: 16px;
    min-width: 60px;
    user-select:none;
    transition: background-color 0.3s ease;
  }
  button:active {
    background-color: #3678d8;
  }
  #steer-left, #steer-right {
    min-width: 50px;
    font-weight: 700;
    font-size: 18px;
    padding: 10px 14px;
  }
</style>
</head>
<body>
  <div id="container"></div>
  <div id="warning">가로 모드에서만 게임이 가능합니다.<br>기기를 가로로 회전해주세요.</div>
  <div id="overlay">속도: 0.0 km/h</div>
  <div id="controls">
    <div class="button-group" id="steering-buttons">
      <button id="steer-left">◀</button>
      <button id="steer-right">▶</button>
    </div>
    <div class="button-group" id="pedal-buttons">
      <button id="accelerate">엑셀</button>
      <button id="brake">브레이크</button>
    </div>
  </div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/js/controls/OrbitControls.js"></script>
  <!-- Ammo.js -->
  <script src="https://cdn.jsdelivr.net/npm/ammo.js@0.0.10/ammo.wasm.js"></script>

  <script>
    // 가로 모드 체크 및 경고
    const warningEl = document.getElementById('warning');
    function checkOrientation() {
      if(window.innerWidth < window.innerHeight){
        warningEl.style.display = 'flex';
      } else {
        warningEl.style.display = 'none';
      }
    }
    window.addEventListener('resize', checkOrientation);
    window.addEventListener('orientationchange', checkOrientation);
    checkOrientation();

    let container, camera, scene, renderer, controls;
    let physicsWorld, clock;
    let vehicle, vehicleRigidBody, tuning, vehicleRayCaster;
    let speed = 0;
    const maxSpeed = 200; // km/h 제한
    let engineForce = 0;
    let brakingForce = 0;
    const steeringIncrement = 0.04;
    const steeringClamp = 0.6;
    let steering = 0;

    const overlay = document.getElementById('overlay');

    Ammo().then(start);

    function start() {
      container = document.getElementById('container');

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x444444);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.set(0, 5, -10);

      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enabled = false;

      setupPhysicsWorld();
      createGround();
      createVehicle();

      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(5, 10, 7);
      scene.add(light);

      scene.add(new THREE.AmbientLight(0x404040));

      clock = new THREE.Clock();

      bindEvents();

      window.addEventListener('resize', onWindowResize);

      animate();
    }

    function setupPhysicsWorld() {
      const collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
      const dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
      const overlappingPairCache = new Ammo.btDbvtBroadphase();
      const solver = new Ammo.btSequentialImpulseConstraintSolver();
      physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
      physicsWorld.setGravity(new Ammo.btVector3(0, -9.81, 0));
    }

    function createGround() {
      const pos = {x: 0, y: -0.5, z: 0};
      const scale = {x: 100, y: 1, z: 100};
      const quat = {x: 0, y: 0, z: 0, w: 1};

      const groundMaterial = new THREE.MeshPhongMaterial({color: 0x505050});
      const ground = new THREE.Mesh(new THREE.BoxGeometry(scale.x, scale.y, scale.z), groundMaterial);
      ground.position.set(pos.x, pos.y, pos.z);
      scene.add(ground);

      const transform = new Ammo.btTransform();
      transform.setIdentity();
      transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
      transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
      const motionState = new Ammo.btDefaultMotionState(transform);

      const colShape = new Ammo.btBoxShape(new Ammo.btVector3(scale.x * 0.5, scale.y * 0.5, scale.z * 0.5));
      colShape.setMargin(0.05);

      const localInertia = new Ammo.btVector3(0, 0, 0);
      const rbInfo = new Ammo.btRigidBodyConstructionInfo(0, motionState, colShape, localInertia);
      const body = new Ammo.btRigidBody(rbInfo);

      physicsWorld.addRigidBody(body);
    }

    function createVehicle() {
      const chassisWidth = 1.8;
      const chassisHeight = 0.6;
      const chassisLength = 4;
      const massVehicle = 1200;

      const geometry = new THREE.BoxGeometry(chassisWidth, chassisHeight, chassisLength);
      const material = new THREE.MeshPhongMaterial({color: 0xff0000});
      const chassisMesh = new THREE.Mesh(geometry, material);
      chassisMesh.castShadow = true;
      chassisMesh.receiveShadow = true;
      scene.add(chassisMesh);

      const transform = new Ammo.btTransform();
      transform.setIdentity();
      transform.setOrigin(new Ammo.btVector3(0, 1, 0));
      const quat = new Ammo.btQuaternion(0, 0, 0, 1);
      transform.setRotation(quat);
      const motionState = new Ammo.btDefaultMotionState(transform);

      const colShape = new Ammo.btBoxShape(new Ammo.btVector3(chassisWidth / 2, chassisHeight / 2, chassisLength / 2));
      colShape.setMargin(0.05);

      const localInertia = new Ammo.btVector3(0, 0, 0);
      colShape.calculateLocalInertia(massVehicle, localInertia);

      const rbInfo = new Ammo.btRigidBodyConstructionInfo(massVehicle, motionState, colShape, localInertia);
      vehicleRigidBody = new Ammo.btRigidBody(rbInfo);
      vehicleRigidBody.setActivationState(4);

      physicsWorld.addRigidBody(vehicleRigidBody);

      tuning = new Ammo.btVehicleTuning();
      vehicleRayCaster = new Ammo.btDefaultVehicleRaycaster(physicsWorld);
      vehicle = new Ammo.btRaycastVehicle(tuning, vehicleRigidBody, vehicleRayCaster);
      vehicle.setCoordinateSystem(0, 1, 2);
      physicsWorld.addAction(vehicle);

      const wheelDirectionCS0 = new Ammo.btVector3(0, -1, 0);
      const wheelAxleCS = new Ammo.btVector3(-1, 0, 0);

      const suspensionRestLength = 0.6;
      const wheelRadius = 0.4;

      // 앞 바퀴 좌표 (차체 앞쪽 양쪽)
      const frontLeftPos = new Ammo.btVector3(chassisWidth / 2 - 0.3, chassisHeight / 2, chassisLength / 2 - 0.7);
      const frontRightPos = new Ammo.btVector3(-chassisWidth / 2 + 0.3, chassisHeight / 2, chassisLength / 2 - 0.7);

      // 뒷 바퀴 좌표
      const backLeftPos = new Ammo.btVector3(chassisWidth / 2 - 0.3, chassisHeight / 2, -chassisLength / 2 + 0.7);
      const backRightPos = new Ammo.btVector3(-chassisWidth / 2 + 0.3, chassisHeight / 2, -chassisLength / 2 + 0.7);

      vehicle.addWheel(frontLeftPos, wheelDirectionCS0, wheelAxleCS, suspensionRestLength, wheelRadius, tuning, true);
      vehicle.addWheel(frontRightPos, wheelDirectionCS0, wheelAxleCS, suspensionRestLength, wheelRadius, tuning, true);
      vehicle.addWheel(backLeftPos, wheelDirectionCS0, wheelAxleCS, suspensionRestLength, wheelRadius, tuning, false);
      vehicle.addWheel(backRightPos, wheelDirectionCS0, wheelAxleCS, suspensionRestLength, wheelRadius, tuning, false);

      for(let i=0; i < vehicle.getNumWheels(); i++){
        const wheel = vehicle.getWheelInfo(i);
        wheel.set_m_suspensionStiffness(20);
        wheel.set_m_wheelsDampingRelaxation(2.3);
        wheel.set_m_wheelsDampingCompression(4.4);
        wheel.set_m_frictionSlip(1000);
        wheel.set_m_rollInfluence(0.1);
      }

      vehicle.chassisMesh = chassisMesh;
    }

    // 조작 상태
    const actions = {
      accelerate: false,
      brake: false,
      steerLeft: false,
      steerRight: false
    };

    function bindEvents(){
      window.addEventListener('keydown', e=>{
        switch(e.code){
          case 'ArrowUp': case 'KeyW': actions.accelerate = true; break;
          case 'ArrowDown': case 'KeyS': actions.brake = true; break;
          case 'ArrowLeft': case 'KeyA': actions.steerLeft = true; break;
          case 'ArrowRight': case 'KeyD': actions.steerRight = true; break;
        }
      });
      window.addEventListener('keyup', e=>{
        switch(e.code){
          case 'ArrowUp': case 'KeyW': actions.accelerate = false; break;
          case 'ArrowDown': case 'KeyS': actions.brake = false; break;
          case 'ArrowLeft': case 'KeyA': actions.steerLeft = false; break;
          case 'ArrowRight': case 'KeyD': actions.steerRight = false; break;
        }
      });

      // 모바일 터치 이벤트
      document.getElementById('accelerate').addEventListener('touchstart', e=>{ e.preventDefault(); actions.accelerate = true; });
      document.getElementById('accelerate').addEventListener('touchend', e=>{ e.preventDefault(); actions.accelerate = false; });
      document.getElementById('brake').addEventListener('touchstart', e=>{ e.preventDefault(); actions.brake = true; });
      document.getElementById('brake').addEventListener('touchend', e=>{ e.preventDefault(); actions.brake = false; });
      document.getElementById('steer-left').addEventListener('touchstart', e=>{ e.preventDefault(); actions.steerLeft = true; });
      document.getElementById('steer-left').addEventListener('touchend', e=>{ e.preventDefault(); actions.steerLeft = false; });
      document.getElementById('steer-right').addEventListener('touchstart', e=>{ e.preventDefault(); actions.steerRight = true; });
      document.getElementById('steer-right').addEventListener('touchend', e=>{ e.preventDefault(); actions.steerRight = false; });
    }

    function animate(){
      requestAnimationFrame(animate);

      const deltaTime = clock.getDelta();

      updatePhysics(deltaTime);
      updateCamera();

      renderer.render(scene, camera);
    }

    function updatePhysics(deltaTime){
      // 조향 자연 복원 & 조절
      if(actions.steerLeft) steering -= steeringIncrement;
      else if(actions.steerRight) steering += steeringIncrement;
      else {
        if(steering > 0) steering -= steeringIncrement * 0.5;
        else if(steering < 0) steering += steeringIncrement * 0.5;
      }
      steering = Math.min(steeringClamp, Math.max(-steeringClamp, steering));

      // 힘 설정
      const maxEngineForce = 2500;
      const maxBreakingForce = 100;

      engineForce = actions.accelerate ? maxEngineForce : 0;
      brakingForce = actions.brake ? maxBreakingForce : 0;

      // 힘 적용
      vehicle.applyEngineForce(engineForce, 2);
      vehicle.applyEngineForce(engineForce, 3);
      vehicle.setBrake(brakingForce, 2);
      vehicle.setBrake(brakingForce, 3);

      // 조향 적용
      vehicle.setSteeringValue(steering, 0);
      vehicle.setSteeringValue(steering, 1);

      physicsWorld.stepSimulation(deltaTime, 10);

      let tm = vehicle.getChassisWorldTransform();
      let p = tm.getOrigin();
      let q = tm.getRotation();

      vehicle.chassisMesh.position.set(p.x(), p.y(), p.z());
      vehicle.chassisMesh.quaternion.set(q.x(), q.y(), q.z(), q.w());

      // 속도 계산 (m/s → km/h)
      const rb = vehicle.getRigidBody ? vehicle.getRigidBody() : null;
      if(rb){
        let vel = rb.getLinearVelocity();
        speed = vel.length() * 3.6;
      } else {
        speed = 0;
      }
      if(speed > maxSpeed) speed = maxSpeed;

      overlay.textContent = `속도: ${speed.toFixed(1)} km/h`;
    }

    function updateCamera(){
      // 차량 뒤 3인칭 카메라 위치 셋업
      if(!vehicle || !vehicle.chassisMesh) return;
      const relativeCameraOffset = new THREE.Vector3(0, 3, -8);
      const cameraOffset = relativeCameraOffset.applyQuaternion(vehicle.chassisMesh.quaternion);
      const cameraPosition = vehicle.chassisMesh.position.clone().add(cameraOffset);

      camera.position.lerp(cameraPosition, 0.1);
      camera.lookAt(vehicle.chassisMesh.position);
    }

    function onWindowResize(){
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
  </script>
</body>
</html>
