<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>driving</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <style>
    body {
      margin: 0; overflow: hidden; background: #222;
      font-family: 'Arial', sans-serif;
      -webkit-touch-callout: none; -webkit-user-select: none; -moz-user-select: none;
      -ms-user-select: none; user-select: none;
    }
    #container {
      width: 100vw; height: 100vh; position: relative;
      display: flex; justify-content: center; align-items: center;
      background: #222;
    }
    #overlay {
      position: absolute; top: 10px; left: 10px; color: #eee; font-size: 18px;
      user-select: none;
      z-index: 100;
      background: rgba(0,0,0,0.3);
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: bold;
      min-width: 140px;
      text-align: center;
    }
    #warning {
      position: absolute;
      width: 100vw;
      height: 100vh;
      background: #111;
      color: #f44;
      display: none;
      justify-content: center;
      align-items: center;
      font-size: 24px;
      font-weight: bold;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
      z-index: 9999;
    }
    #controls {
      position: absolute;
      bottom: 20px; width: 100%;
      display: flex; justify-content: space-between;
      padding: 0 20px;
      box-sizing: border-box;
      user-select: none;
      z-index: 100;
    }
    .button-group {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    button {
      background: #4f9eff;
      border: none;
      border-radius: 10px;
      color: white;
      font-size: 16px;
      font-weight: 600;
      padding: 12px 18px;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.3s ease;
      min-width: 70px;
    }
    button:active {
      background-color: #3678d8;
    }
    /* 좌우 조향 버튼 */
    #steer-left, #steer-right {
      min-width: 50px;
      padding: 12px 16px;
      font-size: 18px;
      font-weight: 700;
      user-select: none;
    }
    /* 엑셀, 브레이크 버튼 */
    #accelerate, #brake {
      min-width: 60px;
      padding: 12px 16px;
      font-weight: 700;
      font-size: 16px;
      user-select: none;
    }
  </style>
</head>
<body>
  <div id="container"></div>

  <div id="warning">가로 모드에서만 게임이 가능합니다.<br>기기를 가로로 회전해주세요.</div>

  <div id="overlay">속도: 0 km/h</div>

  <div id="controls">
    <div class="button-group" id="steering-buttons">
      <button id="steer-left">◀</button>
      <button id="steer-right">▶</button>
    </div>
    <div class="button-group" id="pedal-buttons">
      <button id="accelerate">엑셀</button>
      <button id="brake">브레이크</button>
    </div>
  </div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
  <!-- OrbitControls for debugging (optional) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/js/controls/OrbitControls.js"></script>
  <!-- Ammo.js -->
  <script src="https://cdn.jsdelivr.net/npm/ammo.js@0.0.10/ammo.wasm.js"></script>

  <script>
    // 가로 모드 강제
    const warningEl = document.getElementById('warning');
    function checkOrientation() {
      if(window.innerWidth < window.innerHeight){
        warningEl.style.display = 'flex';
      } else {
        warningEl.style.display = 'none';
      }
    }
    window.addEventListener('resize', checkOrientation);
    window.addEventListener('orientationchange', checkOrientation);
    checkOrientation();

    // 기본 변수
    let container, camera, scene, renderer, controls;
    let physicsWorld, clock;
    let rigidBodies = [];
    let vehicle, tuning, vehicleRayCaster;
    let speed = 0;
    const maxSpeed = 200; // km/h 제한
    let engineForce = 0;
    let brakingForce = 0;
    let steeringIncrement = 0.04;
    let steeringClamp = 0.6;
    let steering = 0;

    const overlay = document.getElementById('overlay');

    Ammo().then(start);

    function start() {
      container = document.getElementById('container');

      // Three.js scene 셋업
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x444444);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 5, -10);
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(renderer.domElement);

      // OrbitControls (디버깅용)
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 0, 0);
      controls.update();

      // 물리 초기화
      setupPhysicsWorld();

      // 바닥 생성
      createGround();

      // 차량 생성
      createVehicle();

      // 조명
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(5, 10, 7);
      scene.add(light);

      const ambient = new THREE.AmbientLight(0x404040);
      scene.add(ambient);

      clock = new THREE.Clock();

      // 이벤트 바인딩
      bindEvents();

      animate();
    }

    function setupPhysicsWorld() {
      let collisionConfiguration = new Ammo.btDefaultCollisionConfiguration(),
          dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration),
          overlappingPairCache = new Ammo.btDbvtBroadphase(),
          solver = new Ammo.btSequentialImpulseConstraintSolver();

      physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
      physicsWorld.setGravity(new Ammo.btVector3(0, -9.81, 0));
    }

    function createGround() {
      // 바닥은 큰 박스형태
      let pos = {x: 0, y: -0.5, z: 0};
      let scale = {x: 100, y: 1, z: 100};
      let quat = {x: 0, y: 0, z: 0, w: 1};

      let groundMaterial = new THREE.MeshPhongMaterial({color: 0x505050});
      let ground = new THREE.Mesh(new THREE.BoxGeometry(scale.x, scale.y, scale.z), groundMaterial);
      ground.position.set(pos.x, pos.y, pos.z);
      scene.add(ground);

      // Ammo.js 물리 바닥
      let transform = new Ammo.btTransform();
      transform.setIdentity();
      transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
      transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
      let motionState = new Ammo.btDefaultMotionState(transform);

      let colShape = new Ammo.btBoxShape(new Ammo.btVector3(scale.x * 0.5, scale.y * 0.5, scale.z * 0.5));
      colShape.setMargin(0.05);

      let localInertia = new Ammo.btVector3(0, 0, 0);
      let rbInfo = new Ammo.btRigidBodyConstructionInfo(0, motionState, colShape, localInertia);
      let body = new Ammo.btRigidBody(rbInfo);

      physicsWorld.addRigidBody(body);
    }

    function createVehicle() {
      // 차량 본체 메쉬
      let chassisWidth = 1.8, chassisHeight = 0.6, chassisLength = 4;
      let massVehicle = 1200;

      let geometry = new THREE.BoxGeometry(chassisWidth, chassisHeight, chassisLength);
      let material = new THREE.MeshPhongMaterial({color: 0xff0000});
      let chassisMesh = new THREE.Mesh(geometry, material);
      chassisMesh.castShadow = true;
      chassisMesh.receiveShadow = true;
      scene.add(chassisMesh);

      // Ammo.js 차량 본체 강체 생성
      let transform = new Ammo.btTransform();
      transform.setIdentity();
      transform.setOrigin(new Ammo.btVector3(0, 1, 0));
      let quat = new Ammo.btQuaternion(0, 0, 0, 1);
      transform.setRotation(quat);
      let motionState = new Ammo.btDefaultMotionState(transform);

      let colShape = new Ammo.btBoxShape(new Ammo.btVector3(chassisWidth / 2, chassisHeight / 2, chassisLength / 2));
      colShape.setMargin(0.05);

      let localInertia = new Ammo.btVector3(0, 0, 0);
      colShape.calculateLocalInertia(massVehicle, localInertia);

      let rbInfo = new Ammo.btRigidBodyConstructionInfo(massVehicle, motionState, colShape, localInertia);
      let body = new Ammo.btRigidBody(rbInfo);
      body.setActivationState(4); // disable deactivation

      physicsWorld.addRigidBody(body);

      // 차량 raycast 차량 객체 생성
      tuning = new Ammo.btVehicleTuning();
      let vehicleRayCaster = new Ammo.btDefaultVehicleRaycaster(physicsWorld);
      vehicle = new Ammo.btRaycastVehicle(tuning, body, vehicleRayCaster);
      vehicle.setCoordinateSystem(0, 1, 2);
      physicsWorld.addAction(vehicle);

      // 바퀴 위치 지정
      const wheelDirectionCS0 = new Ammo.btVector3(0, -1, 0);
      const wheelAxleCS = new Ammo.btVector3(-1, 0, 0);

      const suspensionRestLength = 0.6;
      const wheelRadius = 0.4;

      // 앞바퀴 (좌우)
      const frontLeftPos = new Ammo.btVector3(chassisWidth / 2 - 0.3, chassisHeight / 2, chassisLength / 2 - 0.7);
      const frontRightPos = new Ammo.btVector3(-chassisWidth / 2 + 0.3, chassisHeight / 2, chassisLength / 2 - 0.7);

      // 뒷바퀴 (좌우)
      const backLeftPos = new Ammo.btVector3(chassisWidth / 2 - 0.3, chassisHeight / 2, -chassisLength / 2 + 0.7);
      const backRightPos = new Ammo.btVector3(-chassisWidth / 2 + 0.3, chassisHeight / 2, -chassisLength / 2 + 0.7);

      // 앞바퀴 추가
      vehicle.addWheel(frontLeftPos, wheelDirectionCS0, wheelAxleCS, suspensionRestLength, wheelRadius, tuning, true);
      vehicle.addWheel(frontRightPos, wheelDirectionCS0, wheelAxleCS, suspensionRestLength, wheelRadius, tuning, true);

      // 뒷바퀴 추가
      vehicle.addWheel(backLeftPos, wheelDirectionCS0, wheelAxleCS, suspensionRestLength, wheelRadius, tuning, false);
      vehicle.addWheel(backRightPos, wheelDirectionCS0, wheelAxleCS, suspensionRestLength, wheelRadius, tuning, false);

      // 바퀴 세팅
      for (let i = 0; i < vehicle.getNumWheels(); i++) {
        let wheel = vehicle.getWheelInfo(i);
        wheel.set_m_suspensionStiffness(20);
        wheel.set_m_wheelsDampingRelaxation(2.3);
        wheel.set_m_wheelsDampingCompression(4.4);
        wheel.set_m_frictionSlip(1000);
        wheel.set_m_rollInfluence(0.1);
      }

      return {body, chassisMesh};
    }

    // 조작 입력 상태
    let actions = {
      accelerate: false,
      brake: false,
      steerLeft: false,
      steerRight: false,
    };

    function bindEvents() {
      window.addEventListener('keydown', e => {
        switch (e.code) {
          case 'ArrowUp': case 'KeyW':
            actions.accelerate = true; break;
          case 'ArrowDown': case 'KeyS':
            actions.brake = true; break;
          case 'ArrowLeft': case 'KeyA':
            actions.steerLeft = true; break;
          case 'ArrowRight': case 'KeyD':
            actions.steerRight = true; break;
        }
      });
      window.addEventListener('keyup', e => {
        switch (e.code) {
          case 'ArrowUp': case 'KeyW':
            actions.accelerate = false; break;
          case 'ArrowDown': case 'KeyS':
            actions.brake = false; break;
          case 'ArrowLeft': case 'KeyA':
            actions.steerLeft = false; break;
          case 'ArrowRight': case 'KeyD':
            actions.steerRight = false; break;
        }
      });

      // 모바일 터치 버튼 바인딩
      document.getElementById('accelerate').addEventListener('touchstart', () => { actions.accelerate = true; });
      document.getElementById('accelerate').addEventListener('touchend', () => { actions.accelerate = false; });
      document.getElementById('brake').addEventListener('touchstart', () => { actions.brake = true; });
      document.getElementById('brake').addEventListener('touchend', () => { actions.brake = false; });
      document.getElementById('steer-left').addEventListener('touchstart', () => { actions.steerLeft = true; });
      document.getElementById('steer-left').addEventListener('touchend', () => { actions.steerLeft = false; });
      document.getElementById('steer-right').addEventListener('touchstart', () => { actions.steerRight = true; });
      document.getElementById('steer-right').addEventListener('touchend', () => { actions.steerRight = false; });
    }

    // 렌더링 & 물리 시뮬레이션 루프
    function animate() {
      requestAnimationFrame(animate);

      const deltaTime = clock.getDelta();

      updatePhysics(deltaTime);
      updateCamera();
      renderer.render(scene, camera);
    }

    function updatePhysics(deltaTime) {
      // 차량 조향 처리
      if (actions.steerLeft) steering -= steeringIncrement;
      else if (actions.steerRight) steering += steeringIncrement;
      else {
        // 조향 자연 복원
        if (steering > 0) steering -= steeringIncrement * 0.5;
        else if (steering < 0) steering += steeringIncrement * 0.5;
      }
      steering = Math.min(steeringClamp, Math.max(-steeringClamp, steering));

      // 가속 및 브레이크 처리
      const maxEngineForce = 2500;
      const maxBreakingForce = 100;

      if (actions.accelerate) engineForce = maxEngineForce;
      else engineForce = 0;

      if (actions.brake) brakingForce = maxBreakingForce;
      else brakingForce = 0;

      // 차량에 힘 적용
      vehicle.applyEngineForce(engineForce, 2);
      vehicle.applyEngineForce(engineForce, 3);

      vehicle.setBrake(brakingForce, 2);
      vehicle.setBrake(brakingForce, 3);

      // 앞 바퀴 조향
      vehicle.setSteeringValue(steering, 0);
      vehicle.setSteeringValue(steering, 1);

      // 물리 월드 스텝
      physicsWorld.stepSimulation(deltaTime, 10);

      // 차량 본체 위치/회전 가져오기
      let tm = vehicle.getChassisWorldTransform();
      let p = tm.getOrigin();
      let q = tm.getRotation();

      vehicle.chassisMesh.position.set(p.x(), p.y(), p.z());
      vehicle.chassisMesh.quaternion.set(q.x(), q.y(), q.z(), q.w());

      // 속도 계산 (m/s → km/h)
      const velocity = vehicle.chassisMesh.userData.velocity = vehicle.chassisMesh.userData.velocity || new THREE.Vector3();
      let linearVelocity = vehicle.vehicleRigidBody ? vehicle.vehicleRigidBody.getLinearVelocity() : null;

      // Ammo에서 속도 직접 가져오기
      const rb = vehicle.getRigidBody ? vehicle.getRigidBody() : null;
      if (rb) {
        let vel = rb.getLinearVelocity();
        speed = vel.length() * 3.6; // m/s → km/h
      } else {
        speed = 0;
      }

      if (speed > maxSpeed) speed = maxSpeed;

      overlay.textContent = `속도: ${speed.toFixed(1)} km/h`;
    }

    function updateCamera() {
      if (!
